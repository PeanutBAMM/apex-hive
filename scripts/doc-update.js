// doc-update.js - Update existing documentation
import { readFile, writeFile, listFiles, pathExists } from "../modules/file-ops.js";
import { promises as fs } from "fs"; // Still need for readdir in some cases
import path from "path";

export async function run(args) {
  const { target = "all", dryRun = false, modules } = args;

  console.error("[DOC-UPDATE] Updating documentation...");

  try {
    const updates = [];

    switch (target) {
      case "all":
        updates.push(...(await updateAllDocs(dryRun, modules)));
        break;

      case "readme":
        updates.push(await updateReadme(dryRun, modules));
        break;

      case "changelog":
        updates.push(await updateChangelog(dryRun, modules));
        break;

      case "api":
        updates.push(...(await updateAPIDocs(dryRun, modules)));
        break;

      default:
        // Update specific file
        updates.push(await updateSpecificDoc(target, dryRun, modules));
    }

    // Filter out null results
    const successfulUpdates = updates.filter((u) => u !== null);

    return {
      status: dryRun ? "dry-run" : "updated",
      target,
      updates: successfulUpdates,
      count: successfulUpdates.length,
      message: dryRun
        ? `Would update ${successfulUpdates.length} file(s)`
        : `Updated ${successfulUpdates.length} file(s)`,
    };
  } catch (error) {
    console.error("[DOC-UPDATE] Error:", error.message);
    return {
      status: "error",
      message: "Failed to update documentation",
      error: error.message,
    };
  }
}

async function updateAllDocs(dryRun, modules) {
  const updates = [];

  // Update README
  const readmeUpdate = await updateReadme(dryRun, modules);
  if (readmeUpdate) updates.push(readmeUpdate);

  // Update API docs
  const apiUpdates = await updateAPIDocs(dryRun, modules);
  updates.push(...apiUpdates);

  // Update CHANGELOG
  const changelogUpdate = await updateChangelog(dryRun, modules);
  if (changelogUpdate) updates.push(changelogUpdate);

  return updates;
}

async function updateReadme(dryRun, modules) {
  const readmePath = "README.md";

  try {
    const exists = await fileExists(readmePath);
    if (!exists) {
      console.error("[DOC-UPDATE] README.md not found, skipping");
      return null;
    }

    const content = await readFile(readmePath);
    const updated = await updateReadmeContent(content, modules);

    if (content === updated) {
      console.error("[DOC-UPDATE] README.md is up to date");
      return null;
    }

    if (!dryRun) {
      await writeFile(readmePath, updated);
    }

    return {
      file: readmePath,
      changes: detectChanges(content, updated),
      status: "updated",
    };
  } catch (error) {
    console.error("[DOC-UPDATE] Failed to update README:", error.message);
    return null;
  }
}

async function updateReadmeContent(content, modules) {
  let updated = content;

  // Update command list from registry
  const registry = (await import("../config/registry.js")).default;
  const commands = Object.keys(registry).filter(
    (cmd) => registry[cmd] !== null,
  );

  // Group commands by category
  const categories = {};
  for (const cmd of commands) {
    const category = cmd.includes(":") ? cmd.split(":")[0] : "core";
    if (!categories[category]) categories[category] = [];
    categories[category].push(cmd);
  }

  // Generate new command section
  let commandSection = "## Available Commands\n\n";
  for (const [category, cmds] of Object.entries(categories)) {
    commandSection += `### ${category.charAt(0).toUpperCase() + category.slice(1)} Commands\n`;
    for (const cmd of cmds.slice(0, 6)) {
      // Show first 6 commands per category
      commandSection += `- \`${cmd}\`\n`;
    }
    if (cmds.length > 6) {
      commandSection += `- ...and ${cmds.length - 6} more\n`;
    }
    commandSection += "\n";
  }

  // Replace command section
  const commandRegex = /## Available Commands[\s\S]*?(?=##|$)/;
  if (commandRegex.test(updated)) {
    updated = updated.replace(commandRegex, commandSection);
  }

  // Update statistics
  updated = updated.replace(
    /ðŸš€ \d+ built-in scripts/,
    `ðŸš€ ${commands.length} built-in scripts`,
  );

  // Update last modified date
  const dateRegex = /\*Generated by Apex Hive on .+?\*/;
  if (dateRegex.test(updated)) {
    updated = updated.replace(
      dateRegex,
      `*Last updated by Apex Hive on ${new Date().toISOString()}*`,
    );
  }

  return updated;
}

async function updateChangelog(dryRun, modules) {
  const changelogPath = "CHANGELOG.md";

  try {
    const exists = await fileExists(changelogPath);
    if (!exists) {
      // Create new changelog
      const content = await createChangelog(modules);

      if (!dryRun) {
        await writeFile(changelogPath, content);
      }

      return {
        file: changelogPath,
        changes: ["Created new file"],
        status: "created",
      };
    }

    // Update existing changelog
    const content = await readFile(changelogPath);
    const updated = await updateChangelogContent(content, modules);

    if (content === updated) {
      console.error("[DOC-UPDATE] CHANGELOG.md is up to date");
      return null;
    }

    if (!dryRun) {
      await writeFile(changelogPath, updated);
    }

    return {
      file: changelogPath,
      changes: detectChanges(content, updated),
      status: "updated",
    };
  } catch (error) {
    console.error("[DOC-UPDATE] Failed to update CHANGELOG:", error.message);
    return null;
  }
}

async function createChangelog(modules) {
  return `# Changelog

All notable changes to Apex Hive will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Initial release of Apex Hive
- 60 built-in scripts for common development tasks
- Natural language support (English & Dutch)
- CI/CD automation with self-healing
- Smart documentation generation
- Extensible recipe system

### Changed
- Migrated from apex-hive-minds architecture
- Simplified to flat script structure
- Removed manager/worker pattern

### Fixed
- MCP stdout pollution issues
- Script loading performance

## [1.0.0] - ${new Date().toISOString().split("T")[0]}

- Initial public release

`;
}

async function updateChangelogContent(content, modules) {
  let updated = content;

  // Check if we need to add a new release section
  const today = new Date().toISOString().split("T")[0];
  const hasToday = content.includes(`## [Unreleased] - ${today}`);

  if (!hasToday && modules?.gitOps) {
    try {
      // Get recent commits
      const recentCommits = await getRecentCommits(modules.gitOps);

      if (recentCommits.length > 0) {
        // Add new unreleased section
        const newSection = generateChangelogSection(recentCommits);

        // Insert after ## [Unreleased]
        const unreleasedIndex = updated.indexOf("## [Unreleased]");
        if (unreleasedIndex > -1) {
          const nextSectionIndex = updated.indexOf(
            "\n## [",
            unreleasedIndex + 1,
          );
          if (nextSectionIndex > -1) {
            updated =
              updated.slice(0, nextSectionIndex) +
              "\n" +
              newSection +
              updated.slice(nextSectionIndex);
          } else {
            updated += "\n" + newSection;
          }
        }
      }
    } catch (error) {
      console.error("[DOC-UPDATE] Failed to get commits:", error.message);
    }
  }

  return updated;
}

async function updateAPIDocs(dryRun, modules) {
  const updates = [];
  const apiDir = "docs/api";

  try {
    if (!(await fileExists(apiDir))) {
      console.error("[DOC-UPDATE] API docs directory not found");
      return updates;
    }

    const fileList = await listFiles(apiDir);
    const files = fileList.map(f => f.name);

    for (const file of files) {
      if (file.endsWith(".md")) {
        const update = await updateAPIDoc(
          path.join(apiDir, file),
          dryRun,
          modules,
        );
        if (update) updates.push(update);
      }
    }
  } catch (error) {
    console.error("[DOC-UPDATE] Failed to update API docs:", error.message);
  }

  return updates;
}

async function updateAPIDoc(docPath, dryRun, modules) {
  try {
    const content = await readFile(docPath);
    const moduleName = path.basename(docPath, ".md");
    const modulePath = `./modules/${moduleName}.js`;

    if (!(await fileExists(modulePath))) {
      console.error(`[DOC-UPDATE] Module ${modulePath} not found`);
      return null;
    }

    // Re-generate documentation for the module
    const moduleSource = await readFile(modulePath);
    const updated = await generateUpdatedAPIDoc(
      content,
      moduleSource,
      moduleName,
    );

    if (content === updated) {
      return null;
    }

    if (!dryRun) {
      await writeFile(docPath, updated);
    }

    return {
      file: docPath,
      changes: detectChanges(content, updated),
      status: "updated",
    };
  } catch (error) {
    console.error(`[DOC-UPDATE] Failed to update ${docPath}:`, error.message);
    return null;
  }
}

async function updateSpecificDoc(target, dryRun, modules) {
  if (!(await fileExists(target))) {
    throw new Error(`File not found: ${target}`);
  }

  const ext = path.extname(target);
  if (ext !== ".md") {
    throw new Error("Can only update markdown files");
  }

  const content = await readFile(target);
  let updated = content;

  // Update based on file type
  if (target.endsWith("README.md")) {
    updated = await updateReadmeContent(content, modules);
  } else if (target.endsWith("CHANGELOG.md")) {
    updated = await updateChangelogContent(content, modules);
  } else {
    // Generic update - just update date
    const dateRegex = /\*Last updated:.+?\*/;
    if (dateRegex.test(updated)) {
      updated = updated.replace(
        dateRegex,
        `*Last updated: ${new Date().toISOString()}*`,
      );
    }
  }

  if (content === updated) {
    return null;
  }

  if (!dryRun) {
    await writeFile(target, updated);
  }

  return {
    file: target,
    changes: detectChanges(content, updated),
    status: "updated",
  };
}

function detectChanges(original, updated) {
  const changes = [];

  const originalLines = original.split("\n");
  const updatedLines = updated.split("\n");

  if (originalLines.length !== updatedLines.length) {
    changes.push(
      `Line count changed: ${originalLines.length} â†’ ${updatedLines.length}`,
    );
  }

  // Simple change detection
  let changedLines = 0;
  for (
    let i = 0;
    i < Math.min(originalLines.length, updatedLines.length);
    i++
  ) {
    if (originalLines[i] !== updatedLines[i]) {
      changedLines++;
    }
  }

  if (changedLines > 0) {
    changes.push(`Modified ${changedLines} line(s)`);
  }

  return changes;
}

async function getRecentCommits(gitOps) {
  // This would use gitOps to get recent commits
  // For now, return empty array
  return [];
}

function generateChangelogSection(commits) {
  let section = `## [Unreleased] - ${new Date().toISOString().split("T")[0]}\n\n`;

  const added = commits.filter((c) => c.message.startsWith("feat:"));
  const fixed = commits.filter((c) => c.message.startsWith("fix:"));
  const changed = commits.filter(
    (c) => c.message.startsWith("refactor:") || c.message.startsWith("chore:"),
  );

  if (added.length > 0) {
    section += "### Added\n";
    for (const commit of added) {
      section += `- ${commit.message.replace(/^feat:\s*/, "")}\n`;
    }
    section += "\n";
  }

  if (changed.length > 0) {
    section += "### Changed\n";
    for (const commit of changed) {
      section += `- ${commit.message.replace(/^(refactor|chore):\s*/, "")}\n`;
    }
    section += "\n";
  }

  if (fixed.length > 0) {
    section += "### Fixed\n";
    for (const commit of fixed) {
      section += `- ${commit.message.replace(/^fix:\s*/, "")}\n`;
    }
    section += "\n";
  }

  return section;
}

async function generateUpdatedAPIDoc(content, moduleSource, moduleName) {
  // This would parse the module source and update the documentation
  // For now, just update the timestamp
  let updated = content;

  const dateRegex = /\*Generated on:.+?\*/;
  if (dateRegex.test(updated)) {
    updated = updated.replace(
      dateRegex,
      `*Updated on: ${new Date().toISOString()}*`,
    );
  }

  return updated;
}

async function fileExists(filePath) {
  try {
    const exists = await pathExists(filePath);
    if (!exists) throw new Error(`File not found: ${filePath}`);
    return true;
  } catch {
    return false;
  }
}
