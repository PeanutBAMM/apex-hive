// doc-update.js - Update existing documentation
import {
  readFile,
  writeFile,
  listFiles,
  pathExists,
} from "../modules/file-ops.js";
import { promises as fs } from "fs"; // Still need for readdir in some cases
import path from "path";

export async function run(args) {
  const { target = "all", sourceFile, dryRun = false, modules } = args;

  console.error("[DOC-UPDATE] Updating documentation...");

  try {
    const updates = [];

    switch (target) {
      case "all":
        updates.push(...(await updateAllDocs(dryRun, modules)));
        break;

      case "readme":
        updates.push(await updateReadme(dryRun, modules));
        break;

      case "changelog":
        updates.push(await updateChangelog(dryRun, modules));
        break;

      case "api":
        updates.push(...(await updateAPIDocs(dryRun, modules)));
        break;

      default:
        // Update specific file
        updates.push(await updateSpecificDoc(target, sourceFile, dryRun, modules));
    }

    // Filter out null results
    const successfulUpdates = updates.filter((u) => u !== null);

    return {
      status: dryRun ? "dry-run" : "updated",
      target,
      updates: successfulUpdates,
      count: successfulUpdates.length,
      message: dryRun
        ? `Would update ${successfulUpdates.length} file(s)`
        : `Updated ${successfulUpdates.length} file(s)`,
    };
  } catch (error) {
    console.error("[DOC-UPDATE] Error:", error.message);
    return {
      status: "error",
      message: "Failed to update documentation",
      error: error.message,
    };
  }
}

async function updateAllDocs(dryRun, modules) {
  const updates = [];

  // Update README
  const readmeUpdate = await updateReadme(dryRun, modules);
  if (readmeUpdate) updates.push(readmeUpdate);

  // Update API docs
  const apiUpdates = await updateAPIDocs(dryRun, modules);
  updates.push(...apiUpdates);

  // Update CHANGELOG
  const changelogUpdate = await updateChangelog(dryRun, modules);
  if (changelogUpdate) updates.push(changelogUpdate);

  return updates;
}

async function updateReadme(dryRun, modules) {
  const readmePath = "README.md";

  try {
    const exists = await fileExists(readmePath);
    if (!exists) {
      console.error("[DOC-UPDATE] README.md not found, skipping");
      return null;
    }

    const content = await readFile(readmePath);
    const updated = await updateReadmeContent(content, modules);

    if (content === updated) {
      console.error("[DOC-UPDATE] README.md is up to date");
      return null;
    }

    if (!dryRun) {
      await writeFile(readmePath, updated);
    }

    return {
      file: readmePath,
      changes: detectChanges(content, updated),
      status: "updated",
    };
  } catch (error) {
    console.error("[DOC-UPDATE] Failed to update README:", error.message);
    return null;
  }
}

async function updateReadmeContent(content, modules) {
  let updated = content;

  // Update command list from registry
  const registry = (await import("../config/registry.js")).default;
  const commands = Object.keys(registry).filter(
    (cmd) => registry[cmd] !== null,
  );

  // Group commands by category
  const categories = {};
  for (const cmd of commands) {
    const category = cmd.includes(":") ? cmd.split(":")[0] : "core";
    if (!categories[category]) categories[category] = [];
    categories[category].push(cmd);
  }

  // Generate new command section
  let commandSection = "## Available Commands\n\n";
  for (const [category, cmds] of Object.entries(categories)) {
    commandSection += `### ${category.charAt(0).toUpperCase() + category.slice(1)} Commands\n`;
    for (const cmd of cmds.slice(0, 6)) {
      // Show first 6 commands per category
      commandSection += `- \`${cmd}\`\n`;
    }
    if (cmds.length > 6) {
      commandSection += `- ...and ${cmds.length - 6} more\n`;
    }
    commandSection += "\n";
  }

  // Replace command section
  const commandRegex = /## Available Commands[\s\S]*?(?=##|$)/;
  if (commandRegex.test(updated)) {
    updated = updated.replace(commandRegex, commandSection);
  }

  // Update statistics
  updated = updated.replace(
    /ðŸš€ \d+ built-in scripts/,
    `ðŸš€ ${commands.length} built-in scripts`,
  );

  // Update last modified date
  const dateRegex = /\*Generated by Apex Hive on .+?\*/;
  if (dateRegex.test(updated)) {
    updated = updated.replace(
      dateRegex,
      `*Last updated by Apex Hive on ${new Date().toISOString()}*`,
    );
  }

  return updated;
}

async function updateChangelog(dryRun, modules) {
  const changelogPath = "CHANGELOG.md";

  try {
    const exists = await fileExists(changelogPath);
    if (!exists) {
      // Create new changelog
      const content = await createChangelog(modules);

      if (!dryRun) {
        await writeFile(changelogPath, content);
      }

      return {
        file: changelogPath,
        changes: ["Created new file"],
        status: "created",
      };
    }

    // Update existing changelog
    const content = await readFile(changelogPath);
    const updated = await updateChangelogContent(content, modules);

    if (content === updated) {
      console.error("[DOC-UPDATE] CHANGELOG.md is up to date");
      return null;
    }

    if (!dryRun) {
      await writeFile(changelogPath, updated);
    }

    return {
      file: changelogPath,
      changes: detectChanges(content, updated),
      status: "updated",
    };
  } catch (error) {
    console.error("[DOC-UPDATE] Failed to update CHANGELOG:", error.message);
    return null;
  }
}

async function createChangelog(modules) {
  return `# Changelog

All notable changes to Apex Hive will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Initial release of Apex Hive
- 60 built-in scripts for common development tasks
- Natural language support (English & Dutch)
- CI/CD automation with self-healing
- Smart documentation generation
- Extensible recipe system

### Changed
- Migrated from apex-hive-minds architecture
- Simplified to flat script structure
- Removed manager/worker pattern

### Fixed
- MCP stdout pollution issues
- Script loading performance

## [1.0.0] - ${new Date().toISOString().split("T")[0]}

- Initial public release

`;
}

async function updateChangelogContent(content, modules) {
  let updated = content;

  // Check if we need to add a new release section
  const today = new Date().toISOString().split("T")[0];
  const hasToday = content.includes(`## [Unreleased] - ${today}`);

  if (!hasToday && modules?.gitOps) {
    try {
      // Get recent commits
      const recentCommits = await getRecentCommits(modules.gitOps);

      if (recentCommits.length > 0) {
        // Add new unreleased section
        const newSection = generateChangelogSection(recentCommits);

        // Insert after ## [Unreleased]
        const unreleasedIndex = updated.indexOf("## [Unreleased]");
        if (unreleasedIndex > -1) {
          const nextSectionIndex = updated.indexOf(
            "\n## [",
            unreleasedIndex + 1,
          );
          if (nextSectionIndex > -1) {
            updated =
              updated.slice(0, nextSectionIndex) +
              "\n" +
              newSection +
              updated.slice(nextSectionIndex);
          } else {
            updated += "\n" + newSection;
          }
        }
      }
    } catch (error) {
      console.error("[DOC-UPDATE] Failed to get commits:", error.message);
    }
  }

  return updated;
}

async function updateAPIDocs(dryRun, modules) {
  const updates = [];
  const apiDir = "docs/api";

  try {
    if (!(await fileExists(apiDir))) {
      console.error("[DOC-UPDATE] API docs directory not found");
      return updates;
    }

    const fileList = await listFiles(apiDir);
    const files = fileList.map((f) => f.name);

    for (const file of files) {
      if (file.endsWith(".md")) {
        const update = await updateAPIDoc(
          path.join(apiDir, file),
          dryRun,
          modules,
        );
        if (update) updates.push(update);
      }
    }
  } catch (error) {
    console.error("[DOC-UPDATE] Failed to update API docs:", error.message);
  }

  return updates;
}

async function updateAPIDoc(docPath, dryRun, modules) {
  try {
    const content = await readFile(docPath);
    const moduleName = path.basename(docPath, ".md");
    const modulePath = `./modules/${moduleName}.js`;

    if (!(await fileExists(modulePath))) {
      console.error(`[DOC-UPDATE] Module ${modulePath} not found`);
      return null;
    }

    // Re-generate documentation for the module
    const moduleSource = await readFile(modulePath);
    const updated = await generateUpdatedAPIDoc(
      content,
      moduleSource,
      moduleName,
    );

    if (content === updated) {
      return null;
    }

    if (!dryRun) {
      await writeFile(docPath, updated);
    }

    return {
      file: docPath,
      changes: detectChanges(content, updated),
      status: "updated",
    };
  } catch (error) {
    console.error(`[DOC-UPDATE] Failed to update ${docPath}:`, error.message);
    return null;
  }
}

async function updateSpecificDoc(target, sourceFile, dryRun, modules) {
  if (!(await fileExists(target))) {
    throw new Error(`File not found: ${target}`);
  }

  const ext = path.extname(target);
  if (ext !== ".md") {
    throw new Error("Can only update markdown files");
  }

  const content = await readFile(target);
  let updated = content;

  // Update based on file type
  if (target.endsWith("README.md")) {
    updated = await updateReadmeContent(content, modules);
  } else if (target.endsWith("CHANGELOG.md")) {
    updated = await updateChangelogContent(content, modules);
  } else if (sourceFile) {
    // Update script documentation with new source content
    updated = await updateScriptDoc(content, sourceFile, modules);
  } else {
    // Generic update - just update date
    const dateRegex = /\*Last updated:.+?\*/;
    if (dateRegex.test(updated)) {
      updated = updated.replace(
        dateRegex,
        `*Last updated: ${new Date().toISOString()}*`,
      );
    }
  }

  if (content === updated) {
    return null;
  }

  if (!dryRun) {
    await writeFile(target, updated);
  }

  return {
    file: target,
    changes: detectChanges(content, updated),
    status: "updated",
  };
}

function detectChanges(original, updated) {
  const changes = [];

  const originalLines = original.split("\n");
  const updatedLines = updated.split("\n");

  if (originalLines.length !== updatedLines.length) {
    changes.push(
      `Line count changed: ${originalLines.length} â†’ ${updatedLines.length}`,
    );
  }

  // Simple change detection
  let changedLines = 0;
  for (
    let i = 0;
    i < Math.min(originalLines.length, updatedLines.length);
    i++
  ) {
    if (originalLines[i] !== updatedLines[i]) {
      changedLines++;
    }
  }

  if (changedLines > 0) {
    changes.push(`Modified ${changedLines} line(s)`);
  }

  return changes;
}

async function getRecentCommits(gitOps) {
  // This would use gitOps to get recent commits
  // For now, return empty array
  return [];
}

function generateChangelogSection(commits) {
  let section = `## [Unreleased] - ${new Date().toISOString().split("T")[0]}\n\n`;

  const added = commits.filter((c) => c.message.startsWith("feat:"));
  const fixed = commits.filter((c) => c.message.startsWith("fix:"));
  const changed = commits.filter(
    (c) => c.message.startsWith("refactor:") || c.message.startsWith("chore:"),
  );

  if (added.length > 0) {
    section += "### Added\n";
    for (const commit of added) {
      section += `- ${commit.message.replace(/^feat:\s*/, "")}\n`;
    }
    section += "\n";
  }

  if (changed.length > 0) {
    section += "### Changed\n";
    for (const commit of changed) {
      section += `- ${commit.message.replace(/^(refactor|chore):\s*/, "")}\n`;
    }
    section += "\n";
  }

  if (fixed.length > 0) {
    section += "### Fixed\n";
    for (const commit of fixed) {
      section += `- ${commit.message.replace(/^fix:\s*/, "")}\n`;
    }
    section += "\n";
  }

  return section;
}

async function generateUpdatedAPIDoc(content, moduleSource, moduleName) {
  // This would parse the module source and update the documentation
  // For now, just update the timestamp
  let updated = content;

  const dateRegex = /\*Generated on:.+?\*/;
  if (dateRegex.test(updated)) {
    updated = updated.replace(
      dateRegex,
      `*Updated on: ${new Date().toISOString()}*`,
    );
  }

  return updated;
}

async function fileExists(filePath) {
  try {
    const exists = await pathExists(filePath);
    if (!exists) throw new Error(`File not found: ${filePath}`);
    return true;
  } catch {
    return false;
  }
}

async function updateScriptDoc(docContent, sourceFile, modules) {
  if (!(await fileExists(sourceFile))) {
    console.error(`[DOC-UPDATE] Source file not found: ${sourceFile}`);
    return docContent;
  }

  const sourceContent = await readFile(sourceFile);
  let updated = docContent;

  // Update file stats
  const lines = sourceContent.split("\n");
  const statsRegex = /\*\*Lines\*\*:\s*\d+/;
  if (statsRegex.test(updated)) {
    updated = updated.replace(statsRegex, `**Lines**: ${lines.length}`);
  }

  // Update last modified date
  const dateRegex = /\*\*Last Modified\*\*:\s*.+/;
  if (dateRegex.test(updated)) {
    updated = updated.replace(
      dateRegex,
      `**Last Modified**: ${new Date().toISOString()}`,
    );
  }

  // Extract new functions/classes from source
  const language = path.extname(sourceFile) === ".js" ? "javascript" : "typescript";
  const symbols = extractSymbols(sourceContent, language);

  // Update functions section
  if (symbols.functions.length > 0) {
    const functionsSection = generateFunctionsSection(symbols.functions, language);
    const funcRegex = /## Functions[\s\S]*?(?=##|$)/;
    
    if (funcRegex.test(updated)) {
      updated = updated.replace(funcRegex, functionsSection + "\n");
    } else {
      // Add functions section if it doesn't exist
      const sourceCodeIndex = updated.indexOf("## Source Code");
      if (sourceCodeIndex > -1) {
        updated = updated.slice(0, sourceCodeIndex) + functionsSection + "\n" + updated.slice(sourceCodeIndex);
      }
    }
  }

  // Update classes section if present
  if (symbols.classes.length > 0) {
    const classesSection = generateClassesSection(symbols.classes);
    const classRegex = /## Classes[\s\S]*?(?=##|$)/;
    
    if (classRegex.test(updated)) {
      updated = updated.replace(classRegex, classesSection + "\n");
    }
  }

  return updated;
}

function extractSymbols(content, language) {
  const symbols = {
    functions: [],
    classes: [],
  };

  if (["javascript", "typescript"].includes(language)) {
    // Extract functions
    const funcRegex = /(?:\/\*\*([\s\S]*?)\*\/\s*)?(?:export\s+)?(?:async\s+)?function\s+(\w+)\s*\(([^)]*)\)/g;
    let match;

    while ((match = funcRegex.exec(content)) !== null) {
      const jsdoc = match[1] || "";
      const name = match[2];
      const params = match[3];

      const func = {
        name,
        signature: match[0].replace(/\/\*\*[\s\S]*?\*\/\s*/, ""),
        params: parseParams(params, jsdoc),
        description: extractDescription(jsdoc),
        returns: extractReturns(jsdoc),
      };

      symbols.functions.push(func);
    }

    // Extract arrow functions with const
    const arrowRegex = /(?:\/\*\*([\s\S]*?)\*\/\s*)?(?:export\s+)?const\s+(\w+)\s*=\s*(?:async\s+)?\(([^)]*)\)\s*=>/g;

    while ((match = arrowRegex.exec(content)) !== null) {
      const jsdoc = match[1] || "";
      const name = match[2];
      const params = match[3];

      const func = {
        name,
        signature: match[0].replace(/\/\*\*[\s\S]*?\*\/\s*/, ""),
        params: parseParams(params, jsdoc),
        description: extractDescription(jsdoc),
        returns: extractReturns(jsdoc),
      };

      symbols.functions.push(func);
    }

    // Extract classes
    const classRegex = /(?:\/\*\*([\s\S]*?)\*\/\s*)?(?:export\s+)?class\s+(\w+)/g;

    while ((match = classRegex.exec(content)) !== null) {
      const jsdoc = match[1] || "";
      const name = match[2];

      const cls = {
        name,
        description: extractDescription(jsdoc),
        methods: extractClassMethods(content, name),
      };

      symbols.classes.push(cls);
    }
  }

  return symbols;
}

function parseParams(paramString, jsdoc) {
  const params = [];

  if (paramString.trim()) {
    // Parse parameter names from signature
    const paramNames = paramString
      .split(",")
      .map((p) => {
        const match = p.trim().match(/(\w+)/);
        return match ? match[1] : null;
      })
      .filter(Boolean);

    // Extract param descriptions from JSDoc
    const paramRegex = /@param\s+(?:\{([^}]+)\}\s+)?(\w+)\s*-?\s*(.+)/g;
    const jsdocParams = {};
    let match;

    while ((match = paramRegex.exec(jsdoc)) !== null) {
      jsdocParams[match[2]] = {
        type: match[1],
        description: match[3],
      };
    }

    // Combine
    for (const name of paramNames) {
      params.push({
        name,
        type: jsdocParams[name]?.type || null,
        description: jsdocParams[name]?.description || null,
      });
    }
  }

  return params;
}

function extractDescription(jsdoc) {
  if (!jsdoc) return null;

  // Remove @tags and get first paragraph
  const lines = jsdoc
    .split("\n")
    .map((line) => line.replace(/^\s*\*\s?/, ""))
    .filter((line) => !line.startsWith("@"));

  // Find first non-empty line
  for (const line of lines) {
    if (line.trim()) {
      return line.trim();
    }
  }

  return null;
}

function extractReturns(jsdoc) {
  if (!jsdoc) return null;

  const match = jsdoc.match(/@returns?\s+(?:\{([^}]+)\}\s+)?(.+)/);
  if (match) {
    return match[2].trim();
  }

  return null;
}

function extractClassMethods(content, className) {
  const methods = [];

  // Look for methods after class declaration
  const classStart = content.indexOf(`class ${className}`);
  if (classStart === -1) return methods;

  const afterClass = content.substring(classStart);
  const methodRegex = /(?:async\s+)?(\w+)\s*\([^)]*\)\s*\{/g;
  let match;

  while ((match = methodRegex.exec(afterClass)) !== null) {
    const name = match[1];
    if (name !== "constructor") {
      methods.push({
        name,
        description: null, // Would need more parsing for descriptions
      });
    }
  }

  return methods;
}

function generateFunctionsSection(functions, language) {
  let section = "## Functions\n\n";
  
  for (const func of functions) {
    section += `### ${func.name}\n\n`;
    
    if (func.description) {
      section += `${func.description}\n\n`;
    }
    
    if (func.params.length > 0) {
      section += "**Parameters:**\n";
      for (const param of func.params) {
        section += `- \`${param.name}\`${param.type ? ` (${param.type})` : ""}: ${param.description || "No description"}\n`;
      }
      section += "\n";
    }
    
    if (func.returns) {
      section += `**Returns:** ${func.returns}\n\n`;
    }

    // Add signature
    section += "```" + language + "\n";
    section += func.signature + "\n";
    section += "```\n\n";
  }
  
  return section;
}

function generateClassesSection(classes) {
  let section = "## Classes\n\n";
  
  for (const cls of classes) {
    section += `### ${cls.name}\n\n`;
    
    if (cls.description) {
      section += `${cls.description}\n\n`;
    }

    if (cls.methods.length > 0) {
      section += "#### Methods\n\n";
      for (const method of cls.methods) {
        section += `- **${method.name}**: ${method.description || "No description"}\n`;
      }
      section += "\n";
    }
  }
  
  return section;
}
