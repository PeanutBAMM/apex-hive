// doc-update.js - Update existing documentation
import {
  readFile,
  writeFile,
  listFiles,
  pathExists,
} from "../modules/file-ops.js";
import { promises as fs } from "fs"; // Still need for readdir in some cases
import path from "path";

export async function run(args) {
  const { target = "all", sourceFile, dryRun = false, modules } = args;

  console.error("[DOC-UPDATE] Updating documentation...");

  try {
    const updates = [];

    switch (target) {
      case "all":
        updates.push(...(await updateAllDocs(dryRun, modules)));
        break;

      case "readme":
        updates.push(await updateReadme(dryRun, modules));
        break;

      case "changelog":
        updates.push(await updateChangelog(dryRun, modules));
        break;

      case "api":
        updates.push(...(await updateAPIDocs(dryRun, modules)));
        break;

      default:
        // Update specific file
        updates.push(await updateSpecificDoc(target, sourceFile, dryRun, modules));
    }

    // Filter out null results
    const successfulUpdates = updates.filter((u) => u !== null);

    return {
      status: dryRun ? "dry-run" : "updated",
      target,
      updates: successfulUpdates,
      count: successfulUpdates.length,
      message: dryRun
        ? `Would update ${successfulUpdates.length} file(s)`
        : `Updated ${successfulUpdates.length} file(s)`,
    };
  } catch (error) {
    console.error("[DOC-UPDATE] Error:", error.message);
    return {
      status: "error",
      message: "Failed to update documentation",
      error: error.message,
    };
  }
}

async function updateAllDocs(dryRun, modules) {
  const updates = [];

  // Update README
  const readmeUpdate = await updateReadme(dryRun, modules);
  if (readmeUpdate) updates.push(readmeUpdate);

  // Update API docs
  const apiUpdates = await updateAPIDocs(dryRun, modules);
  updates.push(...apiUpdates);

  // Update CHANGELOG
  const changelogUpdate = await updateChangelog(dryRun, modules);
  if (changelogUpdate) updates.push(changelogUpdate);

  return updates;
}

async function updateReadme(dryRun, modules) {
  const readmePath = "README.md";

  try {
    const exists = await fileExists(readmePath);
    if (!exists) {
      console.error("[DOC-UPDATE] README.md not found, skipping");
      return null;
    }

    const content = await readFile(readmePath);
    const updated = await updateReadmeContent(content, modules);

    if (content === updated) {
      console.error("[DOC-UPDATE] README.md is up to date");
      return null;
    }

    if (!dryRun) {
      await writeFile(readmePath, updated);
    }

    return {
      file: readmePath,
      changes: detectChanges(content, updated),
      status: "updated",
    };
  } catch (error) {
    console.error("[DOC-UPDATE] Failed to update README:", error.message);
    return null;
  }
}

async function updateReadmeContent(content, modules) {
  let updated = content;

  // Update command list from registry
  const registry = (await import("../config/registry.js")).default;
  const commands = Object.keys(registry).filter(
    (cmd) => registry[cmd] !== null,
  );

  // Group commands by category
  const categories = {};
  for (const cmd of commands) {
    const category = cmd.includes(":") ? cmd.split(":")[0] : "core";
    if (!categories[category]) categories[category] = [];
    categories[category].push(cmd);
  }

  // Generate new command section
  let commandSection = "## Available Commands\n\n";
  for (const [category, cmds] of Object.entries(categories)) {
    commandSection += `### ${category.charAt(0).toUpperCase() + category.slice(1)} Commands\n`;
    for (const cmd of cmds.slice(0, 6)) {
      // Show first 6 commands per category
      commandSection += `- \`${cmd}\`\n`;
    }
    if (cmds.length > 6) {
      commandSection += `- ...and ${cmds.length - 6} more\n`;
    }
    commandSection += "\n";
  }

  // Replace command section
  const commandRegex = /## Available Commands[\s\S]*?(?=##|$)/;
  if (commandRegex.test(updated)) {
    updated = updated.replace(commandRegex, commandSection);
  }

  // Update statistics
  updated = updated.replace(
    /ðŸš€ \d+ built-in scripts/,
    `ðŸš€ ${commands.length} built-in scripts`,
  );

  // Update last modified date
  const dateRegex = /\*Generated by Apex Hive on .+?\*/;
  if (dateRegex.test(updated)) {
    updated = updated.replace(
      dateRegex,
      `*Last updated by Apex Hive on ${new Date().toISOString()}*`,
    );
  }

  return updated;
}

async function updateChangelog(dryRun, modules) {
  const changelogPath = "CHANGELOG.md";

  try {
    const exists = await fileExists(changelogPath);
    if (!exists) {
      // Create new changelog
      const content = await createChangelog(modules);

      if (!dryRun) {
        await writeFile(changelogPath, content);
      }

      return {
        file: changelogPath,
        changes: ["Created new file"],
        status: "created",
      };
    }

    // Update existing changelog
    const content = await readFile(changelogPath);
    const updated = await updateChangelogContent(content, modules);

    if (content === updated) {
      console.error("[DOC-UPDATE] CHANGELOG.md is up to date");
      return null;
    }

    if (!dryRun) {
      await writeFile(changelogPath, updated);
    }

    return {
      file: changelogPath,
      changes: detectChanges(content, updated),
      status: "updated",
    };
  } catch (error) {
    console.error("[DOC-UPDATE] Failed to update CHANGELOG:", error.message);
    return null;
  }
}

async function createChangelog(modules) {
  return `# Changelog

All notable changes to Apex Hive will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Initial release of Apex Hive
- 60 built-in scripts for common development tasks
- Natural language support (English & Dutch)
- CI/CD automation with self-healing
- Smart documentation generation
- Extensible recipe system

### Changed
- Migrated from apex-hive-minds architecture
- Simplified to flat script structure
- Removed manager/worker pattern

### Fixed
- MCP stdout pollution issues
- Script loading performance

## [1.0.0] - ${new Date().toISOString().split("T")[0]}

- Initial public release

`;
}

async function updateChangelogContent(content, modules) {
  let updated = content;

  // Check if we need to add a new release section
  const today = new Date().toISOString().split("T")[0];
  const hasToday = content.includes(`## [Unreleased] - ${today}`);

  if (!hasToday && modules?.gitOps) {
    try {
      // Get recent commits
      const recentCommits = await getRecentCommits(modules.gitOps);

      if (recentCommits.length > 0) {
        // Add new unreleased section
        const newSection = generateChangelogSection(recentCommits);

        // Insert after ## [Unreleased]
        const unreleasedIndex = updated.indexOf("## [Unreleased]");
        if (unreleasedIndex > -1) {
          const nextSectionIndex = updated.indexOf(
            "\n## [",
            unreleasedIndex + 1,
          );
          if (nextSectionIndex > -1) {
            updated =
              updated.slice(0, nextSectionIndex) +
              "\n" +
              newSection +
              updated.slice(nextSectionIndex);
          } else {
            updated += "\n" + newSection;
          }
        }
      }
    } catch (error) {
      console.error("[DOC-UPDATE] Failed to get commits:", error.message);
    }
  }

  return updated;
}

async function updateAPIDocs(dryRun, modules) {
  const updates = [];
  const apiDir = "docs/api";

  try {
    if (!(await fileExists(apiDir))) {
      console.error("[DOC-UPDATE] API docs directory not found");
      return updates;
    }

    const fileList = await listFiles(apiDir);
    const files = fileList.map((f) => f.name);

    for (const file of files) {
      if (file.endsWith(".md")) {
        const update = await updateAPIDoc(
          path.join(apiDir, file),
          dryRun,
          modules,
        );
        if (update) updates.push(update);
      }
    }
  } catch (error) {
    console.error("[DOC-UPDATE] Failed to update API docs:", error.message);
  }

  return updates;
}

async function updateAPIDoc(docPath, dryRun, modules) {
  try {
    const content = await readFile(docPath);
    const moduleName = path.basename(docPath, ".md");
    const modulePath = `./modules/${moduleName}.js`;

    if (!(await fileExists(modulePath))) {
      console.error(`[DOC-UPDATE] Module ${modulePath} not found`);
      return null;
    }

    // Re-generate documentation for the module
    const moduleSource = await readFile(modulePath);
    const updated = await generateUpdatedAPIDoc(
      content,
      moduleSource,
      moduleName,
    );

    if (content === updated) {
      return null;
    }

    if (!dryRun) {
      await writeFile(docPath, updated);
    }

    return {
      file: docPath,
      changes: detectChanges(content, updated),
      status: "updated",
    };
  } catch (error) {
    console.error(`[DOC-UPDATE] Failed to update ${docPath}:`, error.message);
    return null;
  }
}

async function updateSpecificDoc(target, sourceFile, dryRun, modules) {
  if (!(await fileExists(target))) {
    throw new Error(`File not found: ${target}`);
  }

  const ext = path.extname(target);
  if (ext !== ".md") {
    throw new Error("Can only update markdown files");
  }

  const content = await readFile(target);
  let updated = content;

  // Check if doc is minimal and needs enrichment
  if (content.length < 2048 && !target.includes("README") && !target.includes("CHANGELOG")) {
    const enriched = await enrichMinimalDoc(target, content, modules);
    if (enriched) {
      updated = enriched;
    }
  }

  // Update based on file type
  if (target.endsWith("README.md")) {
    updated = await updateReadmeContent(content, modules);
  } else if (target.endsWith("CHANGELOG.md")) {
    updated = await updateChangelogContent(content, modules);
  } else if (sourceFile) {
    // Update script documentation with new source content
    updated = await updateScriptDoc(content, sourceFile, modules);
  } else if (!content.includes("## Overview") || content.length < 1000) {
    // Try to enrich minimal documentation
    const enriched = await enrichMinimalDoc(target, content, modules);
    if (enriched) {
      updated = enriched;
    }
  } else {
    // Generic update - just update date
    const dateRegex = /\*Last updated:.+?\*/;
    if (dateRegex.test(updated)) {
      updated = updated.replace(
        dateRegex,
        `*Last updated: ${new Date().toISOString()}*`,
      );
    }
  }

  if (content === updated) {
    return null;
  }

  if (!dryRun) {
    await writeFile(target, updated);
  }

  return {
    file: target,
    changes: detectChanges(content, updated),
    status: "updated",
  };
}

function detectChanges(original, updated) {
  const changes = [];

  const originalLines = original.split("\n");
  const updatedLines = updated.split("\n");

  if (originalLines.length !== updatedLines.length) {
    changes.push(
      `Line count changed: ${originalLines.length} â†’ ${updatedLines.length}`,
    );
  }

  // Simple change detection
  let changedLines = 0;
  for (
    let i = 0;
    i < Math.min(originalLines.length, updatedLines.length);
    i++
  ) {
    if (originalLines[i] !== updatedLines[i]) {
      changedLines++;
    }
  }

  if (changedLines > 0) {
    changes.push(`Modified ${changedLines} line(s)`);
  }

  return changes;
}

async function getRecentCommits(gitOps) {
  // This would use gitOps to get recent commits
  // For now, return empty array
  return [];
}

function generateChangelogSection(commits) {
  let section = `## [Unreleased] - ${new Date().toISOString().split("T")[0]}\n\n`;

  const added = commits.filter((c) => c.message.startsWith("feat:"));
  const fixed = commits.filter((c) => c.message.startsWith("fix:"));
  const changed = commits.filter(
    (c) => c.message.startsWith("refactor:") || c.message.startsWith("chore:"),
  );

  if (added.length > 0) {
    section += "### Added\n";
    for (const commit of added) {
      section += `- ${commit.message.replace(/^feat:\s*/, "")}\n`;
    }
    section += "\n";
  }

  if (changed.length > 0) {
    section += "### Changed\n";
    for (const commit of changed) {
      section += `- ${commit.message.replace(/^(refactor|chore):\s*/, "")}\n`;
    }
    section += "\n";
  }

  if (fixed.length > 0) {
    section += "### Fixed\n";
    for (const commit of fixed) {
      section += `- ${commit.message.replace(/^fix:\s*/, "")}\n`;
    }
    section += "\n";
  }

  return section;
}

async function generateUpdatedAPIDoc(content, moduleSource, moduleName) {
  // This would parse the module source and update the documentation
  // For now, just update the timestamp
  let updated = content;

  const dateRegex = /\*Generated on:.+?\*/;
  if (dateRegex.test(updated)) {
    updated = updated.replace(
      dateRegex,
      `*Updated on: ${new Date().toISOString()}*`,
    );
  }

  return updated;
}

async function fileExists(filePath) {
  try {
    const exists = await pathExists(filePath);
    if (!exists) throw new Error(`File not found: ${filePath}`);
    return true;
  } catch {
    return false;
  }
}

async function updateScriptDoc(docContent, sourceFile, modules) {
  if (!(await fileExists(sourceFile))) {
    console.error(`[DOC-UPDATE] Source file not found: ${sourceFile}`);
    return docContent;
  }

  const sourceContent = await readFile(sourceFile);
  let updated = docContent;

  // Update file stats
  const lines = sourceContent.split("\n");
  const statsRegex = /\*\*Lines\*\*:\s*\d+/;
  if (statsRegex.test(updated)) {
    updated = updated.replace(statsRegex, `**Lines**: ${lines.length}`);
  }

  // Update last modified date
  const dateRegex = /\*\*Last Modified\*\*:\s*.+/;
  if (dateRegex.test(updated)) {
    updated = updated.replace(
      dateRegex,
      `**Last Modified**: ${new Date().toISOString()}`,
    );
  }

  // Extract new functions/classes from source
  const language = path.extname(sourceFile) === ".js" ? "javascript" : "typescript";
  const symbols = extractSymbols(sourceContent, language);

  // Update functions section
  if (symbols.functions.length > 0) {
    const functionsSection = generateFunctionsSection(symbols.functions, language);
    const funcRegex = /## Functions[\s\S]*?(?=##|$)/;
    
    if (funcRegex.test(updated)) {
      updated = updated.replace(funcRegex, functionsSection + "\n");
    } else {
      // Add functions section if it doesn't exist
      const sourceCodeIndex = updated.indexOf("## Source Code");
      if (sourceCodeIndex > -1) {
        updated = updated.slice(0, sourceCodeIndex) + functionsSection + "\n" + updated.slice(sourceCodeIndex);
      }
    }
  }

  // Update classes section if present
  if (symbols.classes.length > 0) {
    const classesSection = generateClassesSection(symbols.classes);
    const classRegex = /## Classes[\s\S]*?(?=##|$)/;
    
    if (classRegex.test(updated)) {
      updated = updated.replace(classRegex, classesSection + "\n");
    }
  }

  return updated;
}

function extractSymbols(content, language) {
  const symbols = {
    functions: [],
    classes: [],
  };

  if (["javascript", "typescript"].includes(language)) {
    // Extract functions
    const funcRegex = /(?:\/\*\*([\s\S]*?)\*\/\s*)?(?:export\s+)?(?:async\s+)?function\s+(\w+)\s*\(([^)]*)\)/g;
    let match;

    while ((match = funcRegex.exec(content)) !== null) {
      const jsdoc = match[1] || "";
      const name = match[2];
      const params = match[3];

      const func = {
        name,
        signature: match[0].replace(/\/\*\*[\s\S]*?\*\/\s*/, ""),
        params: parseParams(params, jsdoc),
        description: extractDescription(jsdoc),
        returns: extractReturns(jsdoc),
      };

      symbols.functions.push(func);
    }

    // Extract arrow functions with const
    const arrowRegex = /(?:\/\*\*([\s\S]*?)\*\/\s*)?(?:export\s+)?const\s+(\w+)\s*=\s*(?:async\s+)?\(([^)]*)\)\s*=>/g;

    while ((match = arrowRegex.exec(content)) !== null) {
      const jsdoc = match[1] || "";
      const name = match[2];
      const params = match[3];

      const func = {
        name,
        signature: match[0].replace(/\/\*\*[\s\S]*?\*\/\s*/, ""),
        params: parseParams(params, jsdoc),
        description: extractDescription(jsdoc),
        returns: extractReturns(jsdoc),
      };

      symbols.functions.push(func);
    }

    // Extract classes
    const classRegex = /(?:\/\*\*([\s\S]*?)\*\/\s*)?(?:export\s+)?class\s+(\w+)/g;

    while ((match = classRegex.exec(content)) !== null) {
      const jsdoc = match[1] || "";
      const name = match[2];

      const cls = {
        name,
        description: extractDescription(jsdoc),
        methods: extractClassMethods(content, name),
      };

      symbols.classes.push(cls);
    }
  }

  return symbols;
}

function parseParams(paramString, jsdoc) {
  const params = [];

  if (paramString.trim()) {
    // Parse parameter names from signature
    const paramNames = paramString
      .split(",")
      .map((p) => {
        const match = p.trim().match(/(\w+)/);
        return match ? match[1] : null;
      })
      .filter(Boolean);

    // Extract param descriptions from JSDoc
    const paramRegex = /@param\s+(?:\{([^}]+)\}\s+)?(\w+)\s*-?\s*(.+)/g;
    const jsdocParams = {};
    let match;

    while ((match = paramRegex.exec(jsdoc)) !== null) {
      jsdocParams[match[2]] = {
        type: match[1],
        description: match[3],
      };
    }

    // Combine
    for (const name of paramNames) {
      params.push({
        name,
        type: jsdocParams[name]?.type || null,
        description: jsdocParams[name]?.description || null,
      });
    }
  }

  return params;
}

function extractDescription(jsdoc) {
  if (!jsdoc) return null;

  // Remove @tags and get first paragraph
  const lines = jsdoc
    .split("\n")
    .map((line) => line.replace(/^\s*\*\s?/, ""))
    .filter((line) => !line.startsWith("@"));

  // Find first non-empty line
  for (const line of lines) {
    if (line.trim()) {
      return line.trim();
    }
  }

  return null;
}

function extractReturns(jsdoc) {
  if (!jsdoc) return null;

  const match = jsdoc.match(/@returns?\s+(?:\{([^}]+)\}\s+)?(.+)/);
  if (match) {
    return match[2].trim();
  }

  return null;
}

function extractClassMethods(content, className) {
  const methods = [];

  // Look for methods after class declaration
  const classStart = content.indexOf(`class ${className}`);
  if (classStart === -1) return methods;

  const afterClass = content.substring(classStart);
  const methodRegex = /(?:async\s+)?(\w+)\s*\([^)]*\)\s*\{/g;
  let match;

  while ((match = methodRegex.exec(afterClass)) !== null) {
    const name = match[1];
    if (name !== "constructor") {
      methods.push({
        name,
        description: null, // Would need more parsing for descriptions
      });
    }
  }

  return methods;
}

function generateFunctionsSection(functions, language) {
  let section = "## Functions\n\n";
  
  for (const func of functions) {
    section += `### ${func.name}\n\n`;
    
    if (func.description) {
      section += `${func.description}\n\n`;
    }
    
    if (func.params.length > 0) {
      section += "**Parameters:**\n";
      for (const param of func.params) {
        section += `- \`${param.name}\`${param.type ? ` (${param.type})` : ""}: ${param.description || "No description"}\n`;
      }
      section += "\n";
    }
    
    if (func.returns) {
      section += `**Returns:** ${func.returns}\n\n`;
    }

    // Add signature
    section += "```" + language + "\n";
    section += func.signature + "\n";
    section += "```\n\n";
  }
  
  return section;
}

function generateClassesSection(classes) {
  let section = "## Classes\n\n";
  
  for (const cls of classes) {
    section += `### ${cls.name}\n\n`;
    
    if (cls.description) {
      section += `${cls.description}\n\n`;
    }

    if (cls.methods.length > 0) {
      section += "#### Methods\n\n";
      for (const method of cls.methods) {
        section += `- **${method.name}**: ${method.description || "No description"}\n`;
      }
      section += "\n";
    }
  }
  
  return section;
}

async function enrichMinimalDoc(docPath, currentContent, modules) {
  try {
    // Extract source file path from documentation
    const sourceMatch = currentContent.match(/\*\*(File|Path)\*\*:\s*`([^`]+)`/);
    if (!sourceMatch) return null;
    
    const sourcePath = sourceMatch[2].replace(/^\.\//, '');
    
    // Check if source file exists
    if (!(await pathExists(sourcePath))) {
      console.error(`[DOC-UPDATE] Source file not found for enrichment: ${sourcePath}`);
      return null;
    }
    
    // Read source file
    const sourceContent = await readFile(sourcePath);
    const language = path.extname(sourcePath) === '.js' ? 'javascript' : 'typescript';
    
    // Extract symbols from source
    const symbols = extractSymbols(sourceContent, language);
    
    // Start building enriched content
    let enriched = currentContent;
    
    // Add or update Overview section if missing or minimal
    if (!enriched.includes('## Overview') || 
        (enriched.match(/## Overview\n\n(.+?)\n\n/s)?.[1] || '').length < 100) {
      const overview = extractDetailedOverview(sourceContent, sourcePath, symbols);
      if (overview) {
        const overviewSection = `## Overview\n\n${overview}\n\n`;
        if (enriched.includes('## Overview')) {
          enriched = enriched.replace(/## Overview\n\n.*?\n\n(?=##|$)/s, overviewSection);
        } else {
          // Insert after File Information
          const infoEnd = enriched.indexOf('\n\n', enriched.indexOf('## File Information'));
          if (infoEnd > -1) {
            enriched = enriched.slice(0, infoEnd + 2) + overviewSection + enriched.slice(infoEnd + 2);
          }
        }
      }
    }
    
    // Add Architecture section for complex modules
    if (symbols.classes.length > 0 || symbols.functions.length > 5) {
      const archSection = generateArchitectureSection(symbols, sourceContent);
      if (archSection && !enriched.includes('## Architecture')) {
        // Insert after Overview
        const overviewEnd = enriched.indexOf('\n\n', enriched.indexOf('## Overview'));
        if (overviewEnd > -1) {
          enriched = enriched.slice(0, overviewEnd + 2) + archSection + enriched.slice(overviewEnd + 2);
        }
      }
    }
    
    // Add Configuration section if relevant
    if (sourceContent.includes('config') || sourceContent.includes('options')) {
      const configSection = extractConfigSection(sourceContent);
      if (configSection && !enriched.includes('## Configuration')) {
        enriched = enriched.replace(/## Usage/s, configSection + '## Usage');
      }
    }
    
    // Add Implementation Details
    const implSection = generateImplementationDetails(symbols, sourceContent);
    if (implSection && !enriched.includes('## Implementation Details')) {
      enriched = enriched.replace(/## Usage/s, implSection + '## Usage');
    }
    
    // Update Usage section with real examples
    const usageExamples = await findUsageExamples(sourcePath, modules);
    if (usageExamples && usageExamples.length > 0) {
      const usageSection = generateEnhancedUsageSection(usageExamples, sourcePath, symbols);
      enriched = enriched.replace(/## Usage[\s\S]*?(?=##|$)/s, usageSection);
    }
    
    return enriched;
    
  } catch (error) {
    console.error(`[DOC-UPDATE] Error enriching doc: ${error.message}`);
    return null;
  }
}

function extractDetailedOverview(sourceContent, sourcePath, symbols) {
  // Try to find file-level JSDoc comment
  const jsdocMatch = sourceContent.match(/^\/\*\*([\s\S]*?)\*\//);
  if (jsdocMatch) {
    const jsdoc = jsdocMatch[1]
      .split('\n')
      .map(line => line.replace(/^\s*\*\s?/, ''))
      .join('\n')
      .trim();
    if (jsdoc.length > 50) return jsdoc;
  }
  
  // Build overview from analysis
  const basename = path.basename(sourcePath, path.extname(sourcePath));
  let overview = `The ${basename} module `;
  
  if (symbols.exports.length > 0) {
    const mainExport = symbols.exports.find(e => e.name === 'run') || 
                      symbols.exports.find(e => e.name === 'default') || 
                      symbols.exports[0];
    if (mainExport) {
      overview += `provides the \`${mainExport.name}\` function `;
    }
  }
  
  if (sourcePath.includes('scripts/')) {
    overview += `as part of the Apex Hive automation system. `;
    const category = detectScriptCategory(basename);
    overview += `This is a ${category} script that `;
  } else if (sourcePath.includes('modules/')) {
    overview += `that provides reusable functionality for `;
  }
  
  // Add purpose based on imports/exports
  const purposes = detectPurpose(sourceContent, symbols);
  if (purposes.length > 0) {
    overview += purposes.join(' and ') + '.';
  }
  
  return overview;
}

function detectScriptCategory(scriptName) {
  const prefix = scriptName.split('-')[0];
  const categories = {
    'ci': 'CI/CD automation',
    'doc': 'documentation management', 
    'git': 'version control',
    'cache': 'cache management',
    'quality': 'code quality',
    'test': 'testing',
    'backlog': 'backlog management'
  };
  return categories[prefix] || 'utility';
}

function detectPurpose(sourceContent, symbols) {
  const purposes = [];
  
  // Detect based on imports
  if (sourceContent.includes('file-ops')) purposes.push('handles file operations');
  if (sourceContent.includes('git-ops')) purposes.push('manages git operations');
  if (sourceContent.includes('unified-cache')) purposes.push('utilizes caching');
  if (sourceContent.includes('execSync') || sourceContent.includes('exec')) purposes.push('executes system commands');
  
  // Detect based on function names
  const funcNames = symbols.functions.map(f => f.name.toLowerCase());
  if (funcNames.some(n => n.includes('parse'))) purposes.push('parses data');
  if (funcNames.some(n => n.includes('validate'))) purposes.push('validates input');
  if (funcNames.some(n => n.includes('generate'))) purposes.push('generates output');
  if (funcNames.some(n => n.includes('fix'))) purposes.push('fixes issues');
  
  return purposes;
}

function generateArchitectureSection(symbols, sourceContent) {
  let section = "## Architecture\n\n";
  
  if (symbols.classes.length > 0) {
    section += "### Class Structure\n\n";
    for (const cls of symbols.classes) {
      section += `- **${cls.name}**`;
      if (cls.extends) section += ` (extends ${cls.extends})`;
      section += `: ${cls.methods.length} methods\n`;
    }
    section += "\n";
  }
  
  section += "### Key Components\n\n";
  
  // Main entry points
  const entryPoints = symbols.functions.filter(f => 
    f.name === 'run' || f.name === 'main' || f.name === 'execute'
  );
  if (entryPoints.length > 0) {
    section += `- **Entry Point**: \`${entryPoints[0].name}\` function\n`;
  }
  
  // Helper functions
  const helpers = symbols.functions.filter(f => 
    !['run', 'main', 'execute'].includes(f.name)
  );
  if (helpers.length > 0) {
    section += `- **Helper Functions**: ${helpers.length} supporting functions\n`;
  }
  
  // Patterns detected
  if (sourceContent.includes('async') || sourceContent.includes('await')) {
    section += "- **Async Operations**: Uses async/await pattern\n";
  }
  if (sourceContent.includes('try') && sourceContent.includes('catch')) {
    section += "- **Error Handling**: Implements try-catch blocks\n";
  }
  
  section += "\n";
  return section;
}

function extractConfigSection(sourceContent) {
  let section = "## Configuration\n\n";
  let hasConfig = false;
  
  // Look for default parameters
  const defaultsMatch = sourceContent.match(/const\s*{\s*([^}]+)\s*}\s*=\s*args/);
  if (defaultsMatch) {
    section += "### Options\n\n";
    const params = defaultsMatch[1].split(',').map(p => p.trim());
    for (const param of params) {
      const [name, defaultValue] = param.split('=').map(s => s.trim());
      if (name && defaultValue) {
        section += `- **${name}**: ${defaultValue}\n`;
        hasConfig = true;
      }
    }
    section += "\n";
  }
  
  // Look for config objects
  const configMatch = sourceContent.match(/const\s+config\s*=\s*{([^}]+)}/);
  if (configMatch) {
    section += "### Configuration Object\n\n```javascript\n";
    section += `const config = {${configMatch[1]}}\n`;
    section += "```\n\n";
    hasConfig = true;
  }
  
  return hasConfig ? section : null;
}

function generateImplementationDetails(symbols, sourceContent) {
  let section = "## Implementation Details\n\n";
  let hasDetails = false;
  
  // Main function flow
  const mainFunc = symbols.functions.find(f => f.name === 'run') || symbols.functions[0];
  if (mainFunc) {
    section += "### Main Function Flow\n\n";
    
    // Extract function body and analyze flow
    const funcBody = extractFunctionBody(sourceContent, mainFunc.name);
    if (funcBody) {
      const steps = analyzeExecutionFlow(funcBody);
      if (steps.length > 0) {
        section += "1. " + steps.join('\n2. ') + "\n\n";
        hasDetails = true;
      }
    }
  }
  
  // Key algorithms
  if (sourceContent.includes('sort(') || sourceContent.includes('filter(') || 
      sourceContent.includes('reduce(') || sourceContent.includes('map(')) {
    section += "### Data Processing\n\n";
    section += "This module uses functional programming patterns for data transformation.\n\n";
    hasDetails = true;
  }
  
  return hasDetails ? section : null;
}

function extractFunctionBody(sourceContent, funcName) {
  const regex = new RegExp(`function\\s+${funcName}\\s*\\([^)]*\\)\\s*{([^}]+)}`);
  const match = sourceContent.match(regex);
  return match ? match[1] : null;
}

function analyzeExecutionFlow(funcBody) {
  const steps = [];
  
  // Look for key operations
  if (funcBody.includes('validate')) steps.push('Validates input parameters');
  if (funcBody.includes('readFile') || funcBody.includes('listFiles')) steps.push('Reads file system data');
  if (funcBody.includes('parse')) steps.push('Parses input data');
  if (funcBody.includes('process') || funcBody.includes('transform')) steps.push('Processes/transforms data');
  if (funcBody.includes('writeFile')) steps.push('Writes output to file system');
  if (funcBody.includes('console.error')) steps.push('Logs progress information');
  if (funcBody.includes('return')) steps.push('Returns structured result');
  
  return steps;
}

async function findUsageExamples(sourcePath, modules) {
  try {
    // Search for usage in test files
    const basename = path.basename(sourcePath, path.extname(sourcePath));
    const testFile = `test/${basename}.test.js`;
    
    if (await pathExists(testFile)) {
      const testContent = await readFile(testFile);
      const examples = extractTestExamples(testContent);
      if (examples.length > 0) return examples;
    }
    
    // Search for usage in other scripts
    // This would need the search module
    return null;
  } catch {
    return null;
  }
}

function extractTestExamples(testContent) {
  const examples = [];
  const testRegex = /it\(['"]([^'"]+)['"],.*?{([\s\S]*?)}\)/g;
  let match;
  
  while ((match = testRegex.exec(testContent)) !== null) {
    examples.push({
      description: match[1],
      code: match[2].trim()
    });
  }
  
  return examples;
}

function generateEnhancedUsageSection(examples, sourcePath, symbols) {
  let section = "## Usage\n\n";
  
  // Basic import
  const basename = path.basename(sourcePath, path.extname(sourcePath));
  section += "### Basic Usage\n\n```javascript\n";
  
  if (sourcePath.includes('scripts/')) {
    section += `// Run via apex command\n`;
    section += `apex ${basename}\n\n`;
    section += `// With options\n`;
    section += `apex ${basename} --option value\n`;
  } else {
    const mainExport = symbols.exports[0];
    if (mainExport) {
      section += `import { ${mainExport.name} } from './${sourcePath}';\n\n`;
      section += `const result = await ${mainExport.name}(options);\n`;
    }
  }
  
  section += "```\n\n";
  
  // Examples from tests
  if (examples && examples.length > 0) {
    section += "### Examples\n\n";
    for (const example of examples.slice(0, 3)) {
      section += `**${example.description}**\n\n`;
      section += "```javascript\n" + example.code + "\n```\n\n";
    }
  }
  
  return section;
}
