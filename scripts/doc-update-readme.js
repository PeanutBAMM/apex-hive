// doc-update-readme.js - Update README.md with current project information
import { promises as fs } from "fs";
import path from "path";

export async function run(args) {
  const { dryRun = false, template = "default", modules } = args;

  console.error("[DOC-UPDATE-README] Updating README.md...");

  try {
    const readmePath = "README.md";

    // Check if README exists
    let content = "";
    let exists = false;

    try {
      content = await fs.readFile(readmePath, "utf8");
      exists = true;
    } catch {
      console.error(
        "[DOC-UPDATE-README] README.md not found, creating new one",
      );
    }

    // Generate updated content
    const updated = exists
      ? await updateExistingReadme(content, modules)
      : await generateNewReadme(template, modules);

    if (exists && content === updated) {
      return {
        status: "up-to-date",
        message: "README.md is already up to date",
      };
    }

    // Calculate changes
    const changes = exists
      ? detectChanges(content, updated)
      : ["Created new file"];

    // Save if not dry run
    if (!dryRun) {
      await fs.writeFile(readmePath, updated);
    }

    return {
      status: dryRun ? "dry-run" : exists ? "updated" : "created",
      file: readmePath,
      changes,
      message: dryRun
        ? `Would ${exists ? "update" : "create"} README.md with ${changes.length} change(s)`
        : `${exists ? "Updated" : "Created"} README.md with ${changes.length} change(s)`,
    };
  } catch (error) {
    console.error("[DOC-UPDATE-README] Error:", error.message);
    return {
      status: "error",
      message: "Failed to update README",
      error: error.message,
    };
  }
}

async function updateExistingReadme(content, modules) {
  let updated = content;

  // Update badges
  updated = updateBadges(updated);

  // Update installation section
  updated = await updateInstallation(updated);

  // Update command list
  updated = await updateCommandList(updated);

  // Update statistics
  updated = await updateStatistics(updated, modules);

  // Update last modified
  updated = updateTimestamp(updated);

  return updated;
}

async function generateNewReadme(template, modules) {
  const projectName = await getProjectName();
  const packageInfo = await getPackageInfo();

  let content = `# ${projectName}\n\n`;

  // Add description
  if (packageInfo.description) {
    content += `${packageInfo.description}\n\n`;
  }

  // Add badges
  content += generateBadges(packageInfo);

  // Installation
  content += `## Installation\n\n\`\`\`bash\nnpm install ${packageInfo.name || projectName}\n\`\`\`\n\n`;

  // Quick Start
  content += `## Quick Start\n\n\`\`\`bash\n# Initialize Apex Hive\napex init\n\n# Search for code\napex search "function name"\n\n# Check documentation\napex doc:check\n\`\`\`\n\n`;

  // Features
  content += await generateFeatures(modules);

  // Available Commands
  content += await generateCommandSection();

  // Configuration
  content += `## Configuration\n\nConfiguration is stored in \`.apex-hive/config.json\`.\n\n`;

  // Contributing
  content += `## Contributing\n\nContributions are welcome! Please read our contributing guidelines.\n\n`;

  // License
  content += `## License\n\n${packageInfo.license || "MIT"}\n\n`;

  // Footer
  content += `---\n*Generated by Apex Hive on ${new Date().toISOString()}*\n`;

  return content;
}

function updateBadges(content) {
  // Update version badge
  const versionRegex =
    /!\[version\]\(https:\/\/img\.shields\.io\/badge\/version-[^)]+\)/;
  if (versionRegex.test(content)) {
    const version = getPackageInfo().then((p) => p.version || "1.0.0");
    content = content.replace(
      versionRegex,
      `![version](https://img.shields.io/badge/version-${version}-blue)`,
    );
  }

  return content;
}

async function updateInstallation(content) {
  const packageInfo = await getPackageInfo();

  // Update package name in installation
  const installRegex = /npm install [^\s]+/g;
  if (installRegex.test(content) && packageInfo.name) {
    content = content.replace(installRegex, `npm install ${packageInfo.name}`);
  }

  return content;
}

async function updateCommandList(content) {
  const registry = (await import("../config/registry.js")).default;
  const commands = Object.keys(registry).filter(
    (cmd) => registry[cmd] !== null,
  );

  // Group by category
  const categories = {};
  for (const cmd of commands) {
    const category = cmd.includes(":") ? cmd.split(":")[0] : "core";
    if (!categories[category]) categories[category] = [];
    categories[category].push(cmd);
  }

  // Generate command section
  let commandSection = "## Available Commands\n\n";

  for (const [category, cmds] of Object.entries(categories)) {
    if (cmds.length === 0) continue;

    commandSection += `### ${category.charAt(0).toUpperCase() + category.slice(1)} Commands\n`;

    // Show first few commands
    const showCommands = cmds.slice(0, 5);
    for (const cmd of showCommands) {
      commandSection += `- \`apex ${cmd}\`\n`;
    }

    if (cmds.length > 5) {
      commandSection += `- ...and ${cmds.length - 5} more\n`;
    }

    commandSection += "\n";
  }

  // Replace existing command section
  const commandRegex = /## Available Commands[\s\S]*?(?=##|$)/;
  if (commandRegex.test(content)) {
    content = content.replace(commandRegex, commandSection);
  } else {
    // Insert before Configuration or Contributing
    const insertPoint = content.search(
      /##\s*(Configuration|Contributing|License)/,
    );
    if (insertPoint > -1) {
      content =
        content.slice(0, insertPoint) +
        commandSection +
        content.slice(insertPoint);
    }
  }

  return content;
}

async function updateStatistics(content, modules) {
  const stats = await gatherStatistics(modules);

  // Update script count
  content = content.replace(
    /\d+ built-in scripts/,
    `${stats.scripts} built-in scripts`,
  );

  // Update file count if mentioned
  content = content.replace(/\d+ files/, `${stats.files} files`);

  return content;
}

function updateTimestamp(content) {
  const timestampRegex =
    /\*(Generated|Updated|Last updated).*?\d{4}-\d{2}-\d{2}.*?\*/;
  const newTimestamp = `*Last updated by Apex Hive on ${new Date().toISOString()}*`;

  if (timestampRegex.test(content)) {
    return content.replace(timestampRegex, newTimestamp);
  } else {
    // Add at end
    return content + `\n---\n${newTimestamp}\n`;
  }
}

async function getProjectName() {
  try {
    const packageInfo = await getPackageInfo();
    return packageInfo.name || path.basename(process.cwd());
  } catch {
    return path.basename(process.cwd());
  }
}

async function getPackageInfo() {
  try {
    const packageJson = await fs.readFile("package.json", "utf8");
    return JSON.parse(packageJson);
  } catch {
    return {};
  }
}

function generateBadges(packageInfo) {
  let badges = "";

  if (packageInfo.version) {
    badges += `![version](https://img.shields.io/badge/version-${packageInfo.version}-blue) `;
  }

  if (packageInfo.license) {
    badges += `![license](https://img.shields.io/badge/license-${packageInfo.license}-green) `;
  }

  badges += `![node](https://img.shields.io/badge/node-%3E%3D18.0.0-brightgreen)\n\n`;

  return badges;
}

async function generateFeatures(modules) {
  const features = [
    "🚀 60+ built-in scripts for development tasks",
    "🌍 Natural language command support",
    "🔍 Fast code search with ripgrep",
    "📚 Automated documentation generation",
    "🤖 CI/CD integration with self-healing",
    "🔧 Extensible recipe system",
  ];

  let content = "## Features\n\n";
  for (const feature of features) {
    content += `- ${feature}\n`;
  }
  content += "\n";

  return content;
}

async function generateCommandSection() {
  const registry = (await import("../config/registry.js")).default;
  const totalCommands = Object.keys(registry).filter(
    (cmd) => registry[cmd] !== null,
  ).length;

  return `## Available Commands\n\nApex Hive includes ${totalCommands} commands. Run \`apex help\` to see all available commands.\n\n### Quick Examples\n\n\`\`\`bash\n# Search for code\napex search "authentication"\n\n# Monitor CI status\napex ci:monitor\n\n# Generate documentation\napex doc:generate\n\n# Run tests\napex test\n\`\`\`\n\n`;
}

async function gatherStatistics(modules) {
  const registry = (await import("../config/registry.js")).default;
  const scripts = Object.keys(registry).filter(
    (cmd) => registry[cmd] !== null,
  ).length;

  let files = 0;
  try {
    const gitFiles = require("child_process")
      .execSync("git ls-files | wc -l", {
        encoding: "utf8",
      })
      .trim();
    files = parseInt(gitFiles) || 0;
  } catch {
    // Git not available
  }

  return { scripts, files };
}

function detectChanges(original, updated) {
  const changes = [];

  if (original.length !== updated.length) {
    changes.push(
      `Content size changed: ${original.length} → ${updated.length} chars`,
    );
  }

  // Check specific sections
  const sections = [
    "Installation",
    "Available Commands",
    "Features",
    "Configuration",
  ];
  for (const section of sections) {
    const originalSection = extractSection(original, section);
    const updatedSection = extractSection(updated, section);

    if (originalSection !== updatedSection) {
      changes.push(`Updated ${section} section`);
    }
  }

  return changes.length > 0 ? changes : ["Minor updates"];
}

function extractSection(content, sectionName) {
  const regex = new RegExp(`##\\s*${sectionName}[\\s\\S]*?(?=##|$)`);
  const match = content.match(regex);
  return match ? match[0] : "";
}
